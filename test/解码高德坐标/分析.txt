查找这个下断点
solid_squarecap





//---------------------------------------------------------
// 解析单个坐标 得到瓦片相对坐标
    function n(a) {
        var b, c, d, f, g;
        c = [];
        d = NaN;
        var h = null
          , k = null;
        f = 0;
        for (g = a.length; f < g; f += 1)
            (b = a[f],
            b = "ASDFGHJKLQWERTYUIO!sdfghjkl".indexOf(b),
            isNaN(d)) ? d = 27 * b : (h ? k || (k = h = null) : h = d + b - 333,
            c.push(d + b - 333),
            d = NaN);
        return c
    }


//---------------------------------------------------------
// 解析坐标串
    function f(a, b, c, d, f, g, h, k, m) {
        for (var p = 0, q = d.length; p < q; p += 1) {
            var r = a.length / 11
              , u = r + 6
              , x = n(d[p])
              , C = l(x, f, h);
            if (1 < C[1].length) {
                for (var x = C[0], G = C[2], y = 0, C = C[1].length; y < C; y += 1) {
                    if (0 < y) {
                        var A = x[2 * y] - x[2 * y - 2]
                          , D = x[2 * y + 1] - x[2 * y - 1];
                        a.Vd += Math.sqrt(A * A + D * D) * (g ? k : 1)
                    }
                    var A = x[2 * y], D = x[2 * y + 1], z = G[y][0], L = G[y][1], E, F;
                    y === C - 1 ? (E = x[2 * C - 2],
                    F = x[2 * C - 1]) : (E = x[2 * y + 2],
                    F = x[2 * y + 3]);
                    var H, N;
                    0 === y ? (H = A,
                    N = D) : (H = x[2 * y - 2],
                    N = x[2 * y - 1]);
                    if (0 !== y) {
                        var P = y === C - 1 ? 0 : -1;
                        a.push(A, D, z, L, 1, H, N, P, E, F, a.Vd);
                        a.push(A, D, z, L, -1, H, N, P, E, F, a.Vd)
                    } else
                        a.push(A, D, z, L, 0, H, N, 0, E, F, a.Vd),
                        a.push(A, D, z, L, 1, H, N, 0, E, F, a.Vd),
                        a.push(A, D, z, L, 1, H, N, 1, E, F, a.Vd),
                        a.push(A, D, z, L, 0, H, N, 1, E, F, a.Vd),
                        a.push(A, D, z, L, -1, H, N, 1, E, F, a.Vd),
                        a.push(A, D, z, L, -1, H, N, 0, E, F, a.Vd),
                        m && (b.push(r + 2, r + 0, r + 3),
                        b.push(r + 2, r + 1, r + 0),
                        b.push(r + 3, r + 0, r + 4),
                        b.push(r + 4, r + 0, r + 5));
                    y !== C - 1 ? (P = 0 === y ? 0 : 1,
                    a.push(A, D, z, L, 1, H, N, P, E, F, a.Vd),
                    a.push(A, D, z, L, -1, H, N, P, E, F, a.Vd)) : (a.push(A, D, z, L, 0, H, N, 0, E, F, a.Vd),
                    a.push(A, D, z, L, 1, H, N, 0, E, F, a.Vd),
                    a.push(A, D, z, L, 1, H, N, -1, E, F, a.Vd),
                    a.push(A, D, z, L, 0, H, N, -1, E, F, a.Vd),
                    a.push(A, D, z, L, -1, H, N, -1, E, F, a.Vd),
                    a.push(A, D, z, L, -1, H, N, 0, E, F, a.Vd));
                    y !== C - 1 ? (b.push(u + 4 * y, u + 4 * y + 3, u + 4 * y + 1),
                    b.push(u + 4 * y, u + 4 * y + 2, u + 4 * y + 3)) : m && (A = u + 4 * (C - 1),
                    b.push(A + 1, A + 2, A + 0),
                    b.push(A + 2, A + 3, A + 0),
                    b.push(A + 0, A + 4, A + 5),
                    b.push(A + 0, A + 3, A + 4))
                }
                c.push(G)
            }
        }
    }

//-------------------------------------------------------------
// 瓦片相对坐标转WEB墨卡托坐标
    function l(a, b, c) {
        var d = 0
          , f = 0
          , d = 256 * b.x
          , f = 256 * b.y;
        b = [];
        for (var g = [], h = [], k = Math.pow(2, 2), l = 0, m = a.length; l < m; l += 2) {
            var n = (d + a[l]) * c - 53109887 * k
              , p = (f + a[l + 1]) * c - 26262068 * k
              , q = h.length;
            if (0 === b.length || n !== h[q - 2] || p !== h[q - 1])
                1 < b.length ? n === h[q - 2] && n === h[q - 4] ? (h[q - 1] = p,
                b[b.length - 1][1] = p,
                g[b.length - 1][1] = a[l + 1]) : p === h[q - 1] && p === h[q - 3] ? (h[q - 2] = n,
                b[b.length - 1][0] = n,
                g[b.length - 1][0] = a[l]) : (h.push(n),
                h.push(p),
                b.push([n, p]),
                g.push([a[l], a[l + 1]])) : (h.push(n),
                h.push(p),
                b.push([n, p]),
                g.push([a[l], a[l + 1]]))
        }
        return [h, b, g]
    }




测试
传入参数 "!DEk!GRY"
传出参数 [155, -11, 157, 5]














